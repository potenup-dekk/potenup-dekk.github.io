---
title: "Logback 환경설정 및 정책 가이드"
date: 2026-02-22 01:37:00 +0900
categories: [Backend]
tags: [logback, log]
author: "SungRyulCho"
---

> **작성자:** 조성률

안녕하세요 팀원 여러분! 본격적인 기능 개발에 앞서, 우리가 작성한 코드가 어떻게 동작하고 있는지 추적하고 장애 발생 시 빠르게 원인을 파악하기 위해 **Logback을 활용한 전역 로깅 환경**을 세팅했습니다.

이 문서는 우리 팀이 **왜 이런 로그 정책을 가져가는지**, 그리고 **개발할 때 어떻게 활용하면 되는지**를 맞추기 위한 온보딩 가이드입니다.

---

# 1. 🎯 우리 팀의 로그 저장 정책 (File Rolling)

서버에 로그를 무한정 쌓아두면 디스크 용량이 꽉 차서(Disk Full) 장애가 발생할 수 있습니다. 이를 방지하기 위해 아래와 같은 제한 정책을 두었습니다.

- **파일 저장 위치:** 로컬 및 서버의 `logs/` 디렉토리 하위 (`logs/dekk.log`)
- **파일 분리 기준 (maxFileSize):** 단일 로그 파일이 **100MB**를 초과하면 새로운 파일로 분리합니다. (예: `dekk-2026-02-21.0.log`, `dekk-2026-02-21.1.log`)
- **보관 주기 (maxHistory):** 최근 **3일**치의 로그만 보관하며, 그 이전 로그는 자동 삭제됩니다.
- **전체 용량 제한 (totalSizeCap):** 로그 폴더의 전체 크기가 **1GB**를 초과하면, 3일이 지나지 않았더라도 가장 오래된 로그부터 선입선출(FIFO)로 자동 삭제됩니다.

> 💡 **왜 3일인가요?**
MVP 1차 기간 동안은 빠른 사이클(매주 목요일 배포, 금요일 QA)로 개발이 진행됩니다. 방대한 로그를 오래 들고 있기보다는, 최근 발생한 이슈를 빠르게 추적하고 디스크 I/O 부하를 줄이는 데 집중했습니다.
>

---

# 2. 🚦 환경별(Profile) 로그 레벨 가이드

우리 프로젝트는 개발 환경(`dev`)과 운영 환경(`prod`)의 목적이 다르기 때문에, 로그 레벨도 다르게 가져갑니다.

### 🛠️ 개발 환경 (`dev`) : `DEBUG` 위주

개발 중에는 "데이터가 잘 들어왔나?", "DB에 쿼리가 제대로 날아갔나?"와 같은 **내부 로직 흐름**을 상세히 들여다봐야 합니다.

- `<logger name="com.dekk" level="DEBUG" />`
    - `com.dekk`는 우리 DEKK 프로젝트의 최상위 패키지입니다. 즉, 프레임워크나 외부 라이브러리의 잡다한 로그는 숨기고 **'우리가 직접 작성한 코드'에서 발생하는 로그만 상세하게(DEBUG) 보겠다**는 의미입니다.
- `<logger name="org.hibernate.SQL" level="DEBUG" />` : JPA가 생성하는 SQL 쿼리를 출력합니다.
- `<logger name="org.hibernate.orm.jdbc.bind" level="TRACE" />` : SQL 쿼리에 실제로 바인딩되는 파라미터(값)를 상세하게(`TRACE`) 출력합니다.

### 🚀 운영 환경 (`prod`) : `INFO` 위주

운영 환경에서 `DEBUG` 레벨을 켜두면 엄청난 양의 로그가 파일에 기록되어 **서버 성능 저하**, **디스크 폭발**, **유저 민감 정보 노출** 등의 문제가 발생합니다.

- 따라서 `prod`에서는 시스템의 정상 작동 정보와 에러 로그만 남기는 `INFO` 레벨을 기본으로 사용합니다.

---

# 3. 💻 개발 시 로그 작성 팁 (How to use)
우리 팀은 로그를 남길 때 System.out.println()을 사용하지 않습니다! 대신 롬복(Lombok)에서 제공하는 @Slf4j 어노테이션을 활용해 주세요. 특히 효진님이 구현하신 GlobalExceptionHandler와 연동하여 아래와 같이 작성하는 것을 권장합니다.

```java
package com.dekk.domain.category.service;

import com.dekk.common.error.BusinessException;
import com.dekk.common.error.GlobalErrorCode;
import lombok.extern.slf4j.Slf4j;
import org.springframework.stereotype.Service;

@Slf4j // 1. 클래스 상단에 어노테이션 추가
@Service
public class CategoryService {

    public void createCategory(String categoryName) {
        // ❌ 안 좋은 예: System.out.println() 사용
        // ❌ 안 좋은 예: 직접 try-catch로 BusinessException을 잡아서 로그 남기기
        // (직접 잡으면 GlobalExceptionHandler가 동작하지 않아 공통 응답을 보낼 수 없습니다!)

        // ⭕ 좋은 예 1: 개발 흐름 파악용 로그 (DEBUG)
        log.debug("카테고리 생성 요청 시작. name: {}", categoryName);

        // ⭕ 좋은 예 2: 검증 실패 시 예외 던지기 (효진님 에러 핸들링 연동)
        if (categoryName == null || categoryName.isBlank()) {
            // 직접 에러 로그를 찍지 않아도 Handler가 'warn' 로그를 남기고 응답을 처리합니다.
            throw new BusinessException(GlobalErrorCode.VALIDATION_ERROR);
        }

        // 로직 수행...

        // ⭕ 좋은 예 3: 주요 성공 지점 로그 (INFO)
        log.info("카테고리 [{}] 생성 완료", categoryName);
    }
}
```

# 📌 요약: 언제 어떤 레벨을 쓸까요?

- `log.trace()`: 거의 쓰지 않음 (SQL 파라미터 등 상세 추적용)
- `log.debug()`: 개발할 때 로직이 어디를 타고 있는지, 변수에 무슨 값이 들었는지 확인할 때 (가장 많이 씁니다!)
- `log.info()`: "API 호출 성공", "서버 시작" 등 시스템의 정상적인 주요 상태 변경을 알릴 때
- `log.warn()`: 예상된 비즈니스 예외 상황 (예: 유효하지 않은 입력값 등)
    - 참고: BusinessException을 던지면 자동으로 warn 로그가 기록됩니다.
- `log.error()`: 시스템 장애, DB 연결 실패 등 즉시 확인이 필요한 치명적인 에러 상황
    - 참고: 핸들러가 처리하지 못한 일반 Exception은 자동으로 error 로그와 스택 트레이스를 기록합니다.

---

### 문서를 읽어보시고 정책 수정이 필요하거나 궁금한 점이 있다면 언제든 코멘트 남겨주세요! 🙌